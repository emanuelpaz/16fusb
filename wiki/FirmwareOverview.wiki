#summary How firmware works.

= Overview =

The development of such a firmware really isn't a trivial thing, especially taking into account the limitations of a simple microcontroller, such as the PIC16F628/648, especially with regard to its speed.

A PIC16F628/648 can work with frequencies up to 20MHz. However, each instruction cycle takes four clock cycles. This means that, in fact, with a 20MHz crystal we have our PIC running on 5MHz (20 / 4 = 5). Doing a little overclock, with a 24MHz crystal, we can run programs on 6MHz (or 6Mips). Since the speed of the USB low-speed is 1.5 Mbps, we can obtain a total of four instructions (6 / 4 = 1.5) to treat each bit of data during transfer. That is, each bit of the USB bus takes the time of four instructions of our PIC.

As it's not hard to see, with only four instructions to encode/decode the NRZI, insert/remove the bit stuffing and even check the end of packet (EOP), the work becomes impossible. Fortunately using a few more tricks we can work around this problem, as we shall see.

For simplicity the software implements only the mandatory transfer type for all USB devices: the Control Transfer, always using endpoint zero. Although this type of transfer is more used to the device setup, we can use it for general purposes too.

In general the firmware, which was written in assembly, can be divided into two parts: ISR and Main Loop.

<br>

= ISR (Interrupt Service Routine) operations =

 * Waits for data transfer starts with the Sync Pattern;
 * Receives and immediately save the package (still coded and bit stuffing) in an input buffer (RX_BUFFER);
 * Checks in the address field if the package is really for device;
 * Checks the packet type (Token or Data);
 * If it's a OUT or SETUP token, saves the PID of the package to know the origin of the data that will come in the next packet;
 * Sends acknowledgment packet (ACK) to the host;
 * Sends a non-acknowledgment (NAK) if the device is not free and require a resend later;
 * Informs MainLoop through ACTION_FLAG how the decoded packet in RXDATA_BUFFER should be treated;
 * If the packet is an IN Token, verifies through ACTION_FLAG if the answer is ready, encodes (in NRZI) and sends the entire contents of TX_BUFFER that must have been previously prepared (with bit stuff or CRC) for another routine inserted in MainLoop;
 * Set ACTION_FLAG free when there's no more data to prepare/send;

 <br>

= Main Loop operations =

 * Checks ACTION_FLAG;
 * Transfers the flow of execution to a point of proper treatment according to ACTION_FLAG;
 * Prepare response to host, inserting bit stuffing and CRC;
 * Adds custom code (functionalities);