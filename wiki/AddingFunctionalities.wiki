#summary Making your own functions

= Adding Functionalities =

The 16FUSB was developed as a core which, through an interface, is able to provide code that will support real functionality to the device. Without the code that add functionality, the firmware responds to all standards requests, fulfilling the entire protocol (including device enumeration), but with no practical application. Following we'll see how codes for custom requests can be added to the core.
First let's see how the source code is organized. The source files can be divided into two groups: core files and interface files.

Core Files: It's the files that make possible all USB communication. No need to be modified to add features.
 * isr.asm: File that contains the code responsible for interrupt service routine (ISR) described above.
 * main.asm: Contains the MainLoop code, also already described above. It makes the integration of all interface files with the firmware core.
 * func.asm: It has general functions used the core.
 * stdreq.asm: Implements the answer for all mandatory standard requests.

Interface files: These files are the interface between the core and the user code. We shall edit them to add new functionalities.
 * vreq.asm: This is the main interface file. All non standard requests are redirected to here via a “call” to the label VendorRequest. This is where we insert the code that handles custom control requests (remember that our device works always with Control Transfers). In short, the code flow will be on the label VendorRequest whenever we have data from the SETUP stage or when data are requested during DATA stage, ie, on device-to-host direction (IN).
 * out.asm: When receiving data from an OUT token, flow is transferred to this file at ProcessOut label. We may understand this point as a callback function for OUT packets. An OUT package will be available here in DATA stage of a host-to-device request.
 * init.asm: This is the file that allows you to declare initial settings. Anything to do after PIC reset and before it starts accepting interruptions must be declared here.<br><br>

==The VendorRequest:==

Every control transfer starts with a Setup stage, composed by a SETUP token packet  and a DATA0 data packet (see figure below). On table below we can see the Setup request format. Whenever a non standard request happens, the MainLoop calls VendorRequest. If you look at offset 0 description (table below), you’ll notice that VendorRequest will be called if value composed by bit 5 and 6 of bmRequestType field is not zero. These two bit defines if a request is standard, class or vendor request.<br><br>

[http://www.lendlocus.com/sites/default/files/16fusb/images/setup_stage.png]<br><br>

|| *Offset* || *Field* || *Size* || *Value* || *Description* ||
|| 0      || bmRequestType || 1 || Bit-Map || *D7 Data Phase Transfer Direction* <br> 0 = Host to Device <br> 1 = Device to Host <br> *D6..5 Type* <br> 0 = Standard <br> 1 = Class <br> 2 = Vendor <br> 3 = Reserved <br> *D4..0 Recipient* <br> 0 = Device <br> 1 = Interface <br> 2 = Endpoint <br> 3 = Other <br> 4..31 = Reserved ||
|| 1 || bRequest || 1 || Value || Request ||
|| 2 || wValue || 2 || Value || Value ||
|| 4 || wIndex || 2 || Index or Offset || Index ||
|| 6 ||	wLength || 2 || Count || Number of bytes to transfer if there is a data phase ||

<br><br>
In VendorRequest routine, setup data can be read in RXDATA_BUFFER, how we can see in picture below. We can read the offsets just using the form RXDATA_BUFFER+offset, ex: RXDATA_BUFFER+2 reads wValue low. The values in message fields is part of the developer’s imagination.<br><br>

[http://www.lendlocus.com/sites/default/files/16fusb/images/rxdata_buffer_map.png]<br><br>

All kind of requests always have a transfer direction: Device-to-Host - host expects get data from device; Host-to-Device - roughly, host sends data to device.<br><br>

==Device-to-Host request:==

Transfer direction can be checked on bit 7 of bmRequestType field. Once we’re on device-to-host request, we need to compose the answer, because host will send IN requests to get the device response. Thus, MainLoop delegates this to VendorRequest procedure. The answer shall fill 1 to 8 offsets of TX_BUFFER (TX_BUFFER+1 … TX_BUFFER+8). We do not need fill the three others offsets, MainLoop will do it automatically for us.<br><br>

[http://www.lendlocus.com/sites/default/files/16fusb/images/tx_buffer_map.png]<br><br>

Low speed devices are limited to a maximum of 8 bytes packet size. If data stage have more than 8 bytes (wLength > 8), the transaction will be divided in multiple packets. In this case you shall use the FRAME_NUMBER file register for check what part of answer host is asking.<br><br>

Example: wLength = 20 <br>
      Host ask for first 8 bytes  → FRAME_NUMBER = 0 <br>
      Host ask for second 8 bytes → FRAME_NUMBER = 1 <br>
      Host ask for last 4 bytes   → FRAME_NUMBER = 2 <br>
{{{
DeviceToHostRequest:           
    movlw   0x01
    subwf   FRAME_NUMBER,W
    btfsc   STATUS,Z
    goto    Answer_Frame1
    movlw   0x02
    subwf   FRAME_NUMBER,W
    btfsc   STATUS,Z
    goto    Answer_Frame2

Answer_Frame0:
  movlw    0x55
  movwf    TX_BUFFER+1

  movlw    0xAA
  movwf    TX_BUFFER+2

  ...

  movlw   0x55
  movwf    TX_BUFFER+8
 
  return

Answer_Frame1: 
  ...

Answer_Frame2: 
  ...
}}}
<br>

==Host-to-Device request:==

Non standard Host-to-Device request are also always treated firstly by VendorRequest, and only by it if we do not have data stage. For request with data stage, after Setup, host will send OUT packet and MainLoop will transfer control to ProcessOut (out.asm). At this point, RXDATA_BUFFER will reflect data stage content.

For transaction with more than 8 bytes, maybe you need to know which Setup request comes OUT packets. Any Setup information will only be available in VendorRequest. This is a good chance to save some information to be used later. For example, if our requests are based in bRequest field, at VendorRequest we can save it in a overlay section (see 16FUSB RAM use) and make a query for its value later in ProcessOut to know how to proceed with the data in RXDATA_BUFFER.<br><br>

==16FUSB RAM use:==

The core of 16FUSB only uses Bank 0 including some positions of shared area (mirrored). On Bank 0, you can use free positions of shared area and LOCAL_OVERLAY section. To see where LOCAL_OVERLAY start, look at main.asm. For example, in 1.1 version it start at 0x4F address (LOCAL_OVERLAY  UDATA_OVR   0x4F). Using LOCAL_OVERLAY you have the advantage of don’t worry about memory banks.

Bank 1 and 2 are totally free and can be all used by the functionality. Don’t forget to use “banksel” directive to select the right bank for your file register if you use other banks than Bank 0.

Whenever you need to save information to query later in other objects, you shall save it in a overlay section not used by core. Using Bank 1 and 2, you have assurance that the file registers will not be modified by 16FUSB core. Notice that LOCAL_OVERLAY is ever overwritten by core as it is a temporary area.<br>

Example: Different objects accessing same information.
{{{
(vreq.asm)
;Bank 1 file registers
MYAPP_OVERLAY	UDATA_OVR 	0xA0

MYFILE		RES	1

(out.asm)
;Bank 1 file registers
MYAPP_OVERLAY	UDATA_OVR 	0xA0

;MYFILE here will access the same content that MYFILE in vreq.asm
MYFILE		RES	1
}}}

If you need to save data for query later, but not in other objects, you can just leave the linker decide the registers addresses. Banksel directive still must be used as you don’t know where linker will put your variable.<br>

Example:
{{{
MYAPP_VARIABLES	UDATA

MYFILE		RES	1
}}}